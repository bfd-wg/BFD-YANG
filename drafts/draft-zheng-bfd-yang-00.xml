<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc toc="yes"?>
<?rfc tocompact="no"?>
<?rfc tocdepth="6"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<rfc category="std" docName="draft-zheng-bfd-yang-00.txt" ipr="trust200902">
    <front>
        <title abbrev="BFD Yang">Yang Data Model for Bidirectional Forwarding
    Detection (BFD)</title>
        <author fullname="Lianshu Zheng" initials="L." role="editor" surname="Zheng">
            <organization>Huawei Technologies</organization>
            <address>
                <postal>
                    <street/>
                    <city/>
                    <region/>
                    <code/>
                    <country>China</country>
                </postal>
                <email>vero.zheng@huawei.com</email>
            </address>
        </author>
        <author fullname="Reshad Rahman" initials="R." role="editor" surname="Rahman">
            <organization>Cisco Systems</organization>
            <address>
                <postal>
                    <street/>
                    <city/>
                    <region/>
                    <code/>
                    <country>USA</country>
                </postal>
                <email>rrahman@cisco.com</email>
            </address>
        </author>
        <author fullname="Santosh Pallagatti" initials="S." surname="Pallagatti">
            <organization>Juniper Networks</organization>
            <address>
                <postal>
                    <street/>
                    <city/>
                    <region/>
                    <code/>
                    <country>India</country>
                </postal>
                <email>santoshpk@juniper.net</email>
            </address>
        </author>
        <author fullname="Mahesh Jethanandani" initials="M." surname="Jethanandani">
            <organization>Ciena Corporation</organization>
            <address>
                <postal>
                    <street/>
                    <city/>
                    <region/>
                    <code/>
                    <country/>
                </postal>
                <email>mjethanandani@gmail.com</email>
            </address>
        </author>
        <date day="2" month="February" year="2015"/>
        <abstract>
            <t>This document defines a YANG data model that can be used to configure
      and manage Bidirectional Forwarding Detection (BFD).</t>
        </abstract>
        <note title="Requirements Language">

            <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
      document are to be interpreted as described in <xref target="RFC2119">RFC 2119</xref>.</t>
        </note>
    </front>
    <middle>
        <section title="Introduction">
            <t>YANG <xref
                    target="RFC6020"/> is a data definition language that was
      introduced to define the contents of a conceptual data store that allows
      networked devices to be managed using NETCONF <xref
                    target="RFC6241"/>. 
      YANG is proving relevant beyond its initial confines, as bindings to other 
      interfaces (e.g RESTCONF <xref target="I-D.ietf-netconf-restconf"/>) and encodings other than XML (e.g JSON) are being
      defined. Furthermore, YANG data models can be used as the basis of implementation
      for other interfaces, such as CLI and programmatic APIs.</t>

            <t>This document defines a YANG data model that can be used to configure
      and manage Bidirectional Forwarding Detection (BFD)<xref target="RFC5880"/>. 
      BFD is a network protocol which is used for liveness detection of arbitrary paths between systems. Some examples of different types of paths over which we have BFD:</t>

            <t>1) Two systems directly connected via IP. This is known as BFD over single-hop IP <xref target="RFC5881"/>
            </t>
            <t>2) Two systems connected via multiple hops <xref target="RFC5883"/>
            </t>

            <t>3) Two systems connected via MPLS Label Switched Paths (LSPs) <xref target="RFC5884"/>
            </t>

            <t>4) Two systems connected via a Link Aggregation Group (LAG) interface <xref target="RFC7130"/>
            </t>

            <t>BFD typically does not operate on its own. Various control protocols, aka BFD clients, use the services provided by BFD for their own operation <xref target="RFC5882"/>. The obvious candidates which use BFD are those which do not have Hellos to detect failures (e.g. static routes) and routing protocols whose Hellos do not suport sub-second failure detection, e.g OSPF and IS-IS.
		</t>
            <section title="Contributors">
                <t/>
            </section>
        </section>
        <section title="Design of the Data Model  ">
            <t/>
            <section title="Design of configuration model">
                <t/>

                <t>The configuration model consists mainly of the parameters specified in <xref target="RFC5880"/>. Some examples are desired minimum transmit interval, required minimum receive interval, detection multiplier etc </t>
                <t>Some implementations have BFD configuration under the BFD client, e.g. BFD configuration is under routing applications such as OSPF, IS-IS, BGP etc. Other implementations have BFD configuration centralized, i.e outside the multiple BFD clients. In the sections below we address both approaches.</t>
                <figure align="left">
                    <preamble/>
                    <artwork align="left">
          </artwork>
                </figure>
                <section title="Centralized BFD configuration">
                    <t>The BFD data model consists of configuring BFD sessions of different types (e.g. single-hop IP, multi-hop IP etc). Since the different session types have different keys we have a list per session type, but we use a grouping to share the common  configuration data between the different session types.</t>
                    <t/>
                    <section anchor="COMMON-BFD-CFG" title="Common BFD configuration">

                        <t> The common BFD session configuration items are put in a grouping to be used in multiple places, these items are:
          <list
                                hangIndent="8" style="hanging">
                                <t hangText="local-multiplier">

                                    <vspace/>This is the detection time multiplier as defined in <xref target="RFC5880"/>.</t>
                                <t hangText="desired-min-tx-interval">

                                    <vspace/>This is the Desired Min TX Interval as defined in <xref target="RFC5880"/>.</t>
                                <t hangText="required-min-rx-interval">

                                    <vspace/>This is the Required Min RX Interval as defined in <xref target="RFC5880"/>.</t>
                                <t hangText="demand-enabled">

                                    <vspace/>Set to True to enable demand mode as defined in <xref target="RFC5880"/>.</t>
                                <t hangText="enable-authentication">
                                    <vspace/>Set to True to enable BFD authentication.</t>
                                <t hangText="authentication-algorithm">
                                    <vspace/>Authentication algorithm to use (if enabled).</t>
                                <t hangText="key-chain-name">
                                    <vspace/>Key-chain to be used for authentication (if enabled).</t>
                            </list>
                        </t>
                    </section>
                    <section anchor="SH-CFG" title="Single-hop IP">

                        <t>We have a list for BFD sessions over single-hop IP. The key consists of:
          <list
                                hangIndent="8" style="hanging">
                                <t hangText="interface">
                                    <vspace/>This is the interface on which the BFD packets for this session are transmitted and received. Examples of an interface are physical media, virtual circuit, tunnel etc.</t>
                                <t hangText="destination address">

                                    <vspace/>Address belonging to the peer system as per <xref target="RFC5881"/>
                                </t>
                            </list>
                        </t>
                        <t>The common configuration data in <xref
                                target="COMMON-BFD-CFG"/> is used for single-hop IP. On top of that common data, we also need configuration data for echo:
          <list
                                hangIndent="8" style="hanging">
                                <t hangText="desired-min-echo-tx-interval">

                                    <vspace/>This is the minimum interval that the local system would like to use when transmitting BFD echo packets. If 0 the echo function as defined in <xref target="RFC5880"/> is disabled.</t>
                                <t hangText="required-min-echo-rx-interval">

                                    <vspace/>The is the Required Min Echo RX Interval as defined in <xref target="RFC5880"/>.</t>
                            </list>
                        </t>
                    </section>
                    <section title="Multi-hop IP">

                        <t>We have a list for BFD sessions over multi-hop IP. The key consists of:
          <list
                                hangIndent="8" style="hanging">
                                <t hangText="source address">

                                    <vspace/>Address belonging to the local system as per <xref target="RFC5883"/>
                                </t>
                                <t hangText="destination address">

                                    <vspace/>Address belonging to the remote system as per <xref target="RFC5883"/>
                                </t>
                                <t hangText="VRF name">
                                    <vspace/>VRF in which the BFD multi-hop session is running</t>
                            </list>
                        </t>
                        <t>The common configuration data in <xref
                                target="COMMON-BFD-CFG"/> is used for multi-hop IP.On top of that common data, we also need TTL:
          <list
                                hangIndent="8" style="hanging">
                                <t hangText="ttl">
                                    <vspace/>TTL of outgoing BFD control packets.</t>
                            </list>
                        </t>
                    </section>
                    <section title="MPLS LSP">
                        <t>TBD</t>
                    </section>
                    <section title="Link Aggregation Group">
                        <t>TBD</t>
                    </section>
                    <section anchor="IF-CFG" title="Per-interface configuration">

                        <t>For implementations which have multiplier and intervals configured under the BFD clients we still need a central location to configure authentication, demand mode etc. This can be done by configuring the following parameters per interface:
          <list
                                hangIndent="8" style="hanging">
                                <t hangText="Common parameters">

                                    <vspace/>The common BFD parameters listed in <xref target="COMMON-BFD-CFG"/>
                                </t>
                                <t hangText="Echo parameters">

                                    <vspace/>The echo parameters listed in <xref target="SH-CFG"/>
                                </t>
                            </list>
                        </t>
                    </section>
                </section>
                <section title="Configuration in BFD clients">
                    <t> When BFD is configured in BFD clients, it is highly desirable to have BFD configuration consistency between those  clients. In this approach we have a grouping for BFD configuration which applications can import in their YANG module:</t>
                    <t>- This provides consistency since the same grouping is being used in all applications making use of BFD</t>
                    <t>- Since not all implementations of those BFD clients have support for BFD, we must use if-feature in the respective YANG modules</t>
                    <t>An application importing the BFD configuration grouping could do so in a hierarchical manner if it has multiple levels at which BFD configuration can be applied. In a subsequent section we provide an example of how a BFD client would use the grouping in such a way.</t>
                    <t> The configuration items are:
          <list
                            hangIndent="8" style="hanging">
                            <t hangText="enabled">
                                <vspace/>Set to True to enable BFD.</t>
                            <t hangText="local-multiplier">

                                <vspace/>This the detection time multiplier as defined in <xref target="RFC5880"/>.</t>
                            <t hangText="desired-min-tx-interval">

                                <vspace/>This the Desired Min TX Interval as defined in <xref target="RFC5880"/>.</t>
                            <t hangText="required-min-rx-interval">

                                <vspace/>This the Required Min RX Interval as defined in <xref target="RFC5880"/>.</t>
                        </list>
                    </t>
                </section>
            </section>
            <section title="Design of operational model">
                <t>The operational model contains both the overall statistics of BFD sessions running on the device and the per session operational statistics. Since BFD is used for liveness detection of arbitrary paths, there is no uniform key to identify a BFD session. e.g. a BFD single-hop IP session is uniquely identified by the combination of destination IP address and interface whereas a multihop IP session is uniquely identified by the combination of source IP address, destination IP address and VRF.  For this reason, for per session operational statistics, we do not have a single list with different type BFD sessions.  Instead we have a container in which we have multiple lists, where each list corresponds to one specific path type for BFD.  For example we have one operational list for BFD single-hop IP, another list for BFD multi-hop IP etc.  In each list, mainly three categories of operational items are shown.  The fundamental information of a BFD session such as the local discriminator, remote discriminator and the capability of supporting demand detect mode are shown in the first category.  A second category includes a BFD session running information, e.g. the FSM the device in and diagnostic code received.  Another example is the actual transmit interval between the control packets, which may be different from the desired minimum transmit interval configured, is shown in this category.  Similar examples are actual received interval between the control packets and the actual transmit interval between the echo packets.  The third category contains the detailed statistics of this session, e.g. when the session went to up/down, how long it has been since the session is up/down.</t>
                <figure align="left">
                    <preamble/>
                    <artwork align="left">
          </artwork>
                </figure>
            </section>
            <section title="Notifications">
                <t>This YANG model defines a list of notifications to inform clients of BFD with important events detected during the protocol operation. Pair of local and remote discriminator identifies a BFD session on local system. Notification also give more important details about BFD sessions e.g. new state, time in previous state, VRF and reason for BFD session state changed.</t>
                <figure align="left">
                    <preamble/>
                    <artwork align="left">
          </artwork>
                </figure>
            </section>
            <section title="RPC Operations">
                <t>TBD</t>
            </section>
            <section title="BFD Configuration Data Hierarchy">
                <section title="Centralized BFD configuration">
                    <t>The following is the centralized configuration data hierarchy: </t>
                    <t>We have a container which contains a list for each session type</t>
                    <t>We have per-interface configuration</t>
                    <figure align="left">
                        <preamble/>
                        <artwork align="left">
module: bfd
   +--rw bfd-cfg
   |  +--rw bfd-session-cfg {bfd-centralized-session-config}?
   |  |  +--rw session-ip-sh* [interface dest-addr]
   |  |  |  +--rw interface                        if:interface-ref
   |  |  |  +--rw dest-addr                        inet:ip-address
   |  |  |  +--rw admin-down?                      boolean
   |  |  |  +--rw local-multiplier?                multiplier
   |  |  |  +--rw desired-min-tx-interval          uint32
   |  |  |  +--rw required-min-rx-interval         uint32
   |  |  |  +--rw demand-enabled?                  boolean
   |  |  |  +--rw enable-authentication?           boolean
   |  |  |  +--rw authentication-parms {bfd-authentication}?
   |  |  |  |  +--rw key-chain-name?   string
   |  |  |  |  +--rw algorithm?        bfd-auth-algorithm
   |  |  |  +--rw desired-min-echo-tx-interval?    uint32
   |  |  |  +--rw required-min-echo-rx-interval?   uint32
   |  |  +--rw session-ip-mh* [vrf-name source-addr dest-addr]
   |  |     +--rw vrf-name                    vrfName
   |  |     +--rw source-addr                 inet:ip-address
   |  |     +--rw dest-addr                   inet:ip-address
   |  |     +--rw admin-down?                 boolean
   |  |     +--rw local-multiplier?           multiplier
   |  |     +--rw desired-min-tx-interval     uint32
   |  |     +--rw required-min-rx-interval    uint32
   |  |     +--rw demand-enabled?             boolean
   |  |     +--rw enable-authentication?      boolean
   |  |     +--rw authentication-parms {bfd-authentication}?
   |  |     |  +--rw key-chain-name?   string
   |  |     |  +--rw algorithm?        bfd-auth-algorithm
   |  |     +--rw tx-ttl?                     TTL
   |  |     +--rw rx-ttl                      TTL
   |  +--rw bfd-interface-cfg* [interface] {bfd-interface-config}?
   |     +--rw interface                        if:interface-ref
   |     +--rw local-multiplier?                multiplier
   |     +--rw desired-min-tx-interval          uint32
   |     +--rw required-min-rx-interval         uint32
   |     +--rw demand-enabled?                  boolean
   |     +--rw enable-authentication?           boolean
   |     +--rw authentication-parms {bfd-authentication}?
   |     |  +--rw key-chain-name?   string
   |     |  +--rw algorithm?        bfd-auth-algorithm
   |     +--rw desired-min-echo-tx-interval?    uint32
   |     +--rw required-min-echo-rx-interval?   uint32
          </artwork>
                    </figure>
                </section>
                <section title="Configuration in BFD clients">
                    <t>The following is the configuration data hierarchy for a hypothetical BFD client called bfd-routing-app, the BFD configuration is supported conditionally via use of if-feature. </t>
                    <t>We have a list of areas and in each area we have a list of interfaces. The BFD configuration grouping is used in a hierarchical fashion, it can be applied in "area" and "interface": </t>
                    <t>- If BFD configuration is applied under an interface, that configuration takes precedence over any BFD configuration (if any) at the area level</t>
                    <t>- If BFD configuration is applied under an "area" and none of the interfaces in that area has BFD configuration, then all interfaces belong to the "area" in question inherit the BFD configuration for the area in question.</t>
                    <t>- If the BFD client implementation supports "interface all", then all the interfaces belonging to that area will inherit the BFD configuration under "interface all". Along with this if there are specific interface configuration then specific interface will override the "interface all" parameters.</t>
                    <figure align="left">
                        <preamble/>
                        <artwork align="left">
module: bfd-routing-app
   +--rw area* [area-id]
      +--rw area-id      uint32
      +--rw bfd-cfg
      |  +--rw enabled?                    boolean
      |  +--rw local-multiplier?           multiplier
      |  +--rw desired-min-tx-interval     uint32
      |  +--rw required-min-rx-interval    uint32
      +--rw interface* [interface]
         +--rw interface    if:interface-ref
         +--rw bfd-cfg
            +--rw enabled?                    boolean
            +--rw local-multiplier?           multiplier
            +--rw desired-min-tx-interval     uint32
            +--rw required-min-rx-interval    uint32


          </artwork>
                    </figure>
                </section>
            </section>
            <section title="Operational Data Hierarchy">
                <t>The complete data hierarchy of BFD YANG operational model is presented below.</t>
                <figure align="left">
                    <preamble/>
                    <artwork align="left">
module: bfd
   +--rw bfd-oper
      +--ro bfd-session-statistics
      |  +--ro ip-sh-session-num?   uint32
      |  +--ro ip-mh-session-num?   uint32
      |  +--ro total-session-num?   uint32
      |  +--ro session-up-num?      uint32
      |  +--ro sess-down-num?       uint32
      +--ro bfd-session-lists
         +--ro session-ip-sh* [interface dest-addr]
         |  +--ro interface               if:interface-ref
         |  +--ro dest-addr               inet:ip-address
         |  +--ro sesssion-type?          enumeration
         |  +--ro local-discriminator?    discriminator
         |  +--ro remote-discriminator?   discriminator
         |  +--ro remote-multiplier?      multiplier
         |  +--ro out-interface?          if:interface-ref
         |  +--ro demand-capability?      boolean
         |  +--ro session-running*
         |  |  +--ro local-state?               state
         |  |  +--ro remote-state?              state
         |  |  +--ro local-diagnostic?          diagnostic
         |  |  +--ro remote-diagnostic?         diagnostic
         |  |  +--ro detect-Mode?               enumeration
         |  |  +--ro actual-tx-interval?        uint32
         |  |  +--ro actual-rx-interval?        uint32
         |  |  +--ro actual-echo-tx-interval?   uint32
         |  |  +--ro detect-time?               uint32
         |  +--ro sesssion-statistics*
         |     +--ro create-time?         yang:date-and-time
         |     +--ro last-down-time?      yang:date-and-time
         |     +--ro last-up-time?        yang:date-and-time
         |     +--ro receive-pkt?         uint64
         |     +--ro send-pkt?            uint64
         |     +--ro down-count?          uint32
         |     +--ro receive-bad-pkt?     uint64
         |     +--ro send-failed-pkt?     uint64
         |     +--ro short-break-count?   uint32
         +--ro session-ip-mh* [vrfName source-addr dest-addr]
            +--ro vrfName                 vrfName
            +--ro source-addr             inet:ip-address
            +--ro dest-addr               inet:ip-address
            +--ro ttl?                    TTL
            +--ro sesssion-type?          enumeration
            +--ro local-discriminator?    discriminator
            +--ro remote-discriminator?   discriminator
            +--ro remote-multiplier?      multiplier
            +--ro out-interface?          if:interface-ref
            +--ro demand-capability?      boolean
            +--ro session-running*
            |  +--ro local-state?               state
            |  +--ro remote-state?              state
            |  +--ro local-diagnostic?          diagnostic
            |  +--ro remote-diagnostic?         diagnostic
            |  +--ro detect-Mode?               enumeration
            |  +--ro actual-tx-interval?        uint32
            |  +--ro actual-rx-interval?        uint32
            |  +--ro actual-echo-tx-interval?   uint32
            |  +--ro detect-time?               uint32
            +--ro sesssion-statistics*
               +--ro create-time?         yang:date-and-time
               +--ro last-down-time?      yang:date-and-time
               +--ro last-up-time?        yang:date-and-time
               +--ro receive-pkt?         uint64
               +--ro send-pkt?            uint64
               +--ro down-count?          uint32
               +--ro receive-bad-pkt?     uint64
               +--ro send-failed-pkt?     uint64
               +--ro short-break-count?   uint32
            
        </artwork>
                </figure>
            </section>
            <section title="Notifications">
                <t>The BFD YANG data model defines notifications for BFD session state changes.</t>
                <figure align="left">
                    <preamble/>
                    <artwork align="left">
module: bfd
notifications:
   +---n bfd-singlehop-notification    
   |  +--ro local-discr?              discriminator
   |  +--ro remote-discr?             discriminator
   |  +--ro new-state?                state
   |  +--ro state-change-reason?      string
   |  +--ro time-in-previous-state?   string
   |  +--ro dest-addr?                inet:ip-address
   |  +--ro interface?                if:interface-ref
   |  +--ro echo-enabled?             boolean
   +---n bfd-multihop-notification     
      +--ro local-discr?              discriminator
      +--ro remote-discr?             discriminator
      +--ro new-state?                state
      +--ro state-change-reason?      string
      +--ro time-in-previous-state?   string
      +--ro dest-addr?                inet:ip-address
      +--ro vrf-name?                 vrfName
      +--ro source-addr?              inet:ip-address
        </artwork>
                </figure>
            </section>
            <section title="Examples">
                <t/>
            </section>
            <section title="Interaction with other YANG modules">
                <t>TBD.</t>
            </section>
            <section title="BFD Yang Module">
                <figure align="left">
                    <preamble/>
                    <artwork align="left"><![CDATA[
<CODE BEGINS>
module bfd {
  namespace "urn:ietf:params:xml:ns:yang:bfd";
  // replace with IANA namespace when assigned
  prefix "bfd";
   
  import ietf-interfaces {
    prefix "if";
  }

  import ietf-inet-types {
    prefix "inet";
  }

  import ietf-yang-types {
    prefix yang;
  }

  organization "IETF BFD Working Group";

  contact 
    "WG Web:   <http://tools.ietf.org/wg/bfd>
     WG List:  <rtg-bfd@ietf.org>
     WG Chair: Jeff Haas
     WG Chair: Nobo Akiya
     Editor:   Lianshu Zheng and Reshad Rahman";

  description 
    "This module contains the YANG definition for BFD parameters as
     per RFC5880, RFC5881 and RFC5883";

  revision 2015-03-05 {
    description "Initial revision.";
  }

  typedef discriminator {
    type uint32 {
      range 1..4294967295;
    }
  }

  typedef diagnostic {    
    type enumeration {
      enum none {
        value 0;
      }
      enum controlExpiry {
        value 1;
      }
      enum echoFailed {
        value 2;
      }
      enum nborDown {
        value 3;
      }
      enum fwdingReset {
        value 4;
      }
      enum pathDown {
        value 5;
      }
      enum concPathDown {
        value 6;
      }
      enum adminDown {
        value 7;
      }
      enum reverseConcPathDown {
        value 8;
      }
    }
  }

  typedef state {    
    type enumeration {
      enum adminDown {
        value 0;
      }
      enum down {
        value 1;
      }
      enum init {
        value 2;
      }
      enum up {
        value 3;
      }
    }
  }

  typedef multiplier {
    type uint8 {
      range 1..255;
    }
  }

  typedef TTL {
    type uint8 {
      range 1..255;
    }
  }

  typedef bfd-auth-algorithm {
    description "Authentication algorithm";
    type enumeration {
      enum simple-password {
        description
          "Simple password";
      }
      
      enum keyed-md5 {
        description
          "Keyed message Digest 5";
      }
      
      enum meticulous-keyed-md5 {
        description
          "Meticulous keyed message Digest 5";
      }
                                               
      enum keyed-sha-1 {
        description
          "Keyed secure hash algorithm (SHA1) ";
      }
                                               
      enum meticulous-keyed-sha-1 {
        description
          "Meticulous keyed secure hash algorithm (SHA1) ";
      }
    }
  }

  typedef vrfName {
    description "VRF Name";
    type string;
  }        

  feature bfd-centralized-session-config {
    description "BFD session centralized config supported";
  }
  feature bfd-interface-config {
    description "BFD per-interface config supported";
  }
  feature bfd-authentication {
    description "BFD authentication supported";
  }

  grouping bfd-grouping-common-cfg-parms {
    description "BFD grouping for common config parameters";
    
    leaf local-multiplier {
      description "Local multiplier";
      type multiplier;
      default 3;
    }

    leaf desired-min-tx-interval {
      description 
        "Desired minimum transmit interval of control packets";
      type uint32;
      units microseconds;
      mandatory true;
    }

    leaf required-min-rx-interval {
      description 
        "Required minimum receive interval of control packets";
      type uint32;
      units microseconds;
      mandatory true;
    }

    leaf demand-enabled {
      description "To enbale demand mode";
      type boolean;
      default false;
    }

    leaf enable-authentication {
      description 
        "If set, the Authentication Section is present and the session
         is to be authenticated (see RFC5880 section 6.7 for details).";
      type boolean;
      default false;
    }

    container authentication-parms {
      if-feature bfd-authentication;
      leaf key-chain-name {
        description
          "Key chain name";
        must "../algorithm" {
          error-message
            "May not be configured without algorithm";
        }
        type string;
      }
      leaf algorithm {
        description "Authentication algorithm to be used";
        must "../key-chain" {
          error-message
            "May not be configured without key-chain";
        }
        type bfd-auth-algorithm;
      }
    }
  }

  grouping bfd-grouping-echo-cfg-parms {
    description "BFD grouping for echo config parameters";
    leaf desired-min-echo-tx-interval {
      description "Desired minumum transmit interval for echo";
      type uint32;
      units microseconds;
      default 0;
    }

    leaf required-min-echo-rx-interval {
      description "Required minimum receive interval for echo";
      type uint32;
      units microseconds;
      default 0;
    }
  }

  grouping bfd-client-base-cfg-parms {
    description 
      "BFD grouping for base config parameters which could be used 
       by a protocol which is a client of BFD";
    
    container bfd-cfg {
      leaf enabled {
        type boolean;
        description "True if BFD is enabled";
        default false;
      }

      leaf local-multiplier {
        type multiplier;
        default 3;
      }

      leaf desired-min-tx-interval {
        description 
          "Desired minimum transmit interval of control packets";
        type uint32;
        units microseconds;
        mandatory true;
      }

      leaf required-min-rx-interval {
        description 
          "Required minimum receive interval of control packets";
        type uint32;
        units microseconds;
        mandatory true;
      }
    }
  }

  grouping bfd-client-full-cfg-parms {
    description 
      "BFD grouping for complete config parameters which could be used
       by a protocol which is a client of BFD.";
    
    container bfd-cfg {
      leaf enabled {
        type boolean;
        description "True if BFD is enabled";
        default false;
      }

      uses bfd-grouping-common-cfg-parms;

      uses bfd-grouping-echo-cfg-parms;
    }
  }

  grouping bfd-all-session {
    description "BFD session operational information";
    leaf sesssion-type {
      description 
        "BFD session type, this indicates the path type that BFD is 
        running on";
      type enumeration {
        enum ip-single-hop {
          value "0";
          description "IP single hop";
        }
        enum ip-multi-hop {
          value "1";
          description "IP multi hop";
        }
      }
    }
    leaf local-discriminator {
      description "Local discriminator";
      type discriminator;
    }
    leaf remote-discriminator {
      description "Remote discriminator";
      type discriminator;
    }
    leaf remote-multiplier {
      description "Remote multiplier";
      type multiplier;
    }
    leaf out-interface {
      description "Outgoing physical interface name";
      type if:interface-ref;
    }                
    leaf demand-capability{
      description "Local demand mode capability";
      type boolean;
    }                

    list session-running {
      description "BFD session running information";
      leaf local-state {
        type state;
      }
      leaf remote-state {
        type state;
      } 
      leaf local-diagnostic {
        type diagnostic;
      }
      leaf remote-diagnostic {
        type diagnostic;
      }
      leaf detect-Mode {
        description "Detect mode";
        type enumeration {
          enum async-with-echo {
            value "0";
            description "Async with echo";
          }
          enum async-without-echo {
            value "1";
            description "Async without echo";
          }
          enum demand-with-echo {
            value "2";
            description "Demand with echo";
          }
          enum demand-without-echo {
            value "3";
            description "Demand without echo";
          }
        }
      }
      leaf actual-tx-interval {
        description "Actual transmit interval";
        type uint32;
        units microseconds;
      }
      leaf actual-rx-interval {
        description "Actual receive interval";
        type uint32;
        units microseconds;
      }
      leaf actual-echo-tx-interval {
        description "Actual echo transmit interval";
        type uint32;
        units microseconds;
      }
      leaf detect-time {
        description "Detect time";
        type uint32;
        units microseconds;
      }
    }

    list sesssion-statistics {
      description "BFD session statistics";

      leaf create-time {
        description 
          "Time and date when session was created";
        type yang:date-and-time;
      }
      leaf last-down-time {
        description 
          "Time and date of last time the session went down";
        type yang:date-and-time;
      }
      leaf last-up-time {
        description 
          "Time and date of last time the session went up";
        type yang:date-and-time;
      }
      leaf receive-pkt {
        description "Received Packet Count";
        type uint64;
      }
      leaf send-pkt {
        description "Sent Packet Count";
        type uint64;
      }
      leaf down-count {
        description "Session Down Count";
        type uint32;
      }
      leaf receive-bad-pkt {
        description "Received bad packet count";
        type uint64;
      }
      leaf send-failed-pkt {
        description "Packet Failed to Send Count";
        type uint64;
      }
      leaf short-break-count {
        description "Shortbreak count";
        default "0";
        type uint32;
      }
    }
  }

  container bfd-cfg {
    container bfd-session-cfg {
      if-feature bfd-centralized-session-config;
      list session-ip-sh {
        key "interface dest-addr";
        leaf interface {
          description 
            "Interface on which the IP single-hop session is running.";
          type if:interface-ref;
        }
        leaf dest-addr {
          description
            "IP address of the peer";
          type inet:ip-address;
        }
        leaf admin-down {
          description 
            "Is the BFD session administratively down";
          type boolean;
          default false;
        }
        uses bfd-grouping-common-cfg-parms;

        uses bfd-grouping-echo-cfg-parms;
      }

      list session-ip-mh {

        key "vrf-name source-addr dest-addr";
        leaf vrf-name {
          description "Routing instance";
          type vrfName;
        }
        leaf source-addr {
          description 
            "Local IP address";
          type inet:ip-address;
        }
        leaf dest-addr {
          description
            "IP address of the peer";
          type inet:ip-address;
        }
        leaf admin-down {
          description 
            "Is the BFD session administratively down";
          type boolean;
          default false;
        }
        uses bfd-grouping-common-cfg-parms;

        leaf tx-ttl {
          type TTL;
          default 255;
          description "TTL of outgoing BFD control packets";
        }
        leaf rx-ttl {
          type TTL;
          description 
            "Minimum allowed TTL value for incoming BFD control 
            packets";
          mandatory true;
        }
      }
    }

    list bfd-interface-cfg {
      if-feature bfd-interface-config;

      description "Per-interface BFD configuration";
      key interface;
      leaf interface {
        type if:interface-ref;
      }
      uses bfd-grouping-common-cfg-parms;

      uses bfd-grouping-echo-cfg-parms;   

    }
  }

  container bfd-oper {
    container bfd-session-statistics {
      config "false";
      description "BFD session number";
      leaf ip-sh-session-num {
        description "IP single hop session number";
        config "false";
        type uint32;
      }
      leaf ip-mh-session-num {
        description "IP multi hop session Number";
        config "false";
        type uint32;
      }
      leaf total-session-num {
        description "Total session number";
        config "false";
        type uint32;
      }
      leaf session-up-num {
        description "Session up number";
        config "false";
        type uint32;
      }
      leaf sess-down-num {
        description "Session down number";
        config "false";
        type uint32;
      }
    }
    
    container bfd-session-lists {
      config false;
      list session-ip-sh {
        key "interface dest-addr";
        leaf interface {
          type if:interface-ref;
        }
        leaf dest-addr {
          type inet:ip-address;
        }

        uses bfd-all-session;
      }

      list session-ip-mh {
        key "vrfName source-addr dest-addr";
        leaf vrfName {
          type vrfName;
        }
        leaf source-addr {
          type inet:ip-address;
        }
        leaf dest-addr {
          type inet:ip-address;
        }
        leaf ttl {
          description "TTL of session";
          config "false";
          type TTL;
        }
        uses bfd-all-session;
      }
    }
  }
  
  grouping bfd-notification-params {
    description
      "This group describes common params that will be send 
        as part of BFD notification";
        
    leaf local-discr {
      description "BFD local discriminator";
      type discriminator;
    }
        
    leaf remote-discr {
      description "BFD remote discriminator";
      type discriminator;
    }
        
    leaf new-state {
      description "Current BFD state";
      type state;
    }
        
    leaf state-change-reason {
      description "BFD state change reason";
      type string;
    }
        
    leaf time-in-previous-state {
      description "How long the BFD session was in the previous state";
      type string;
    }
        
    leaf dest-addr {
      description "BFD peer address";
      type inet:ip-address;
    }
  }
    
  notification bfd-singlehop-notification {

    uses bfd-notification-params;
        
    leaf interface {
      description "Interface to which this BFD session belongs to";
      type if:interface-ref;
    }
        
    leaf echo-enabled {
      description "Was echo enabled for BFD";
      type boolean;
    }
  }
    
    
  notification bfd-multihop-notification {

    uses bfd-notification-params;
        
    leaf vrf-name {
      description "Routing instance";
      type vrfName;
    }
        
    leaf source-addr {
      description "BFD local address";
      type inet:ip-address;
    }
  }
}

        ]]></artwork>
                </figure>
            </section>
            <section title="BFD Client Example Configuration Yang Module">
                <figure align="left">
                    <preamble/>
                    <artwork align="left">

module bfd-routing-app {
   namespace "urn:cisco:params:xml:ns:yang:bfdroutingapp";
   prefix bfd-routing-app;

   import bfd {
     prefix "bfd";
   }

   import ietf-interfaces {
     prefix "if";
   }

   organization
     "ACME";
   contact
     "acme@acme.com";

   description
     "Testing BFD grouping (simulating a routing application)";

   revision 2015-02-14 {
     description
       "Initial revision.";
   }

   feature routing-app-bfd {
     description "BFD configuration under routing-app";
   }

   list area {
     description
       "Specify a routing area.";

     key "area-id";

     leaf area-id {
       type uint32;
     }

     uses bfd:bfd-client-base-cfg-parms {
       if-feature routing-app-bfd;
     }

     list interface {
       key "interface";
       leaf interface {
         type if:interface-ref;
       }
       uses bfd:bfd-client-base-cfg-parms {
         if-feature routing-app-bfd;
       }
     }

   }
}
        </artwork>
                </figure>
            </section>
            <section title="Security Considerations">
                <t>The YANG module defined in this memo is designed to be accessed via the NETCONF protocol [RFC6241]. The lowest NETCONF layer is the secure transport layer and the mandatory to implement secure transport is SSH [RFC6242]. The NETCONF access control model [RFC6536] provides the means to restrict access for particular NETCONF users to a pre-configured subset of all available NETCONF protocol operations and content.</t>
                <t>The YANG module has writeable data nodes which can be used for creation of BFD sessions and modification of BFD session parameters. The system should "police" creation of BFD sessions to prevent new sessions from causing existing BFD sessions to fail. For BFD session modification, the BFD protocol has mechanisms in place which allow for in service modification. </t>
            </section>
            <section title="IANA Considerations">
                <t>The IANA is requested to as assign a new new namespace URI from the
      IETF XML registry.</t>
                <t>URI:TBD</t>
            </section>
            <section title="Acknowledgements">
                <t>We would also like to thank Nobo Akiya and Jeff Haas for their
      encouragement on this work.</t>
            </section>
        </section>
    </middle>
    <back>
        <references title="Normative References"><?rfc include="reference.RFC.2119"?><?rfc include='reference.RFC.6020'?><?rfc include='reference.RFC.6241'?><?rfc include='reference.RFC.5880'?><?rfc include='reference.RFC.5881'?><?rfc include='reference.RFC.5882'?><?rfc include='reference.RFC.5883'?><?rfc include='reference.RFC.5884'?><?rfc include='reference.RFC.7130'?>
        </references>
        <references title="Informative References"><?rfc include="reference.I-D.ietf-netconf-restconf"?>
        </references>
    </back>
</rfc>
